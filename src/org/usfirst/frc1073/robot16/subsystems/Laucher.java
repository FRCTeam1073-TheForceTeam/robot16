// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1073.robot16.subsystems;

import org.usfirst.frc1073.robot16.Robot;
import org.usfirst.frc1073.robot16.RobotMap;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Laucher extends Subsystem implements PIDSubsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController pullBackMotor = RobotMap.laucherpullBackMotor;
    private final SpeedController elevationMotor = RobotMap.laucherelevationMotor;
    private final AnalogPotentiometer elevationAngle = RobotMap.laucherelevationAngle;
    private final DigitalInput elevationHighLimit = RobotMap.laucherelevationHighLimit;
    private final DigitalInput elevationLowLimit = RobotMap.laucherelevationLowLimit;
    private final DigitalInput laucherBackLimit = RobotMap.laucherlaucherBackLimit;
    private final DigitalInput laucherFrontLimit = RobotMap.laucherlaucherFrontLimit;
    private final Solenoid laucherRelease = RobotMap.laucherlaucherRelease;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    /****************************************
     * 
     * State machine variables
     * 
     *   - emptyForwards: means the motor is
     *   at the front and the grabber is open
     *   - emptyBackwards: means the motor is
     *   at the back and the grabber is open
     *   - emptyMiddle: means the motor is
     *   somewhere in the middle and empty
     *   - primedMiddle: means the motor is
     *   somewhere in the middle and primed
     *   - primed: means the motor is at the
     *   front and the grabber is closed
     *   - loaded: means the motor is at the
     *   back and ready
     *
     ****************************************/
    public enum laucherState { emptyForwards, 
    						 	emptyBackwards, 
    						 	emptyMiddle,
    						 	primedMiddle,
    							primed, 
    							loaded };
    
    private laucherState current; // Current state of the laucher  
    private laucherState destination; // Where you want to be
    
    private final double SPEED = 1.00;
    private final double ELEVATION_SPEED = 0.45;
    
    public Laucher() {
    	current = laucherState.emptyForwards; // This makes the default position of the robot emptyForwards
    	pullBackMotor.setInverted(Robot.invertLaucher);
    	elevationMotor.setInverted(Robot.invertLaucherElevation);
    }
    
    /**********************************
     * 
     * Method to get the current state
     * 
     * @return the current state
     *
     **********************************/
    public laucherState getState() {
    	return current;
    }
    
    /**********************************
     * 
     * Method to get the destination
     * 
     * @return the current destination
     *
     **********************************/
    public laucherState getDestination() {
    	return destination;
    }
    
    public void move(laucherState destination) {
    	
    	// This uses the sensors to check the current position and will set the current position to where ever it actually is
    	if(laucherFrontLimit.get() && laucherRelease.get()) current = laucherState.primed;
    	else if(laucherFrontLimit.get() && !laucherRelease.get()) current = laucherState.emptyForwards;
    	else if(laucherBackLimit.get() && laucherRelease.get()) current = laucherState.loaded;
    	else if(laucherBackLimit.get() && !laucherRelease.get()) current = laucherState.emptyBackwards;
    	else if((!laucherFrontLimit.get() && !laucherBackLimit.get()) && laucherRelease.get()) current = laucherState.primedMiddle;
    	else current = laucherState.emptyMiddle;
    	
    	this.destination = destination; // Sets global to current destination
    	
    	switch(current) {
    	case emptyForwards:
    		switch(destination) {
        		case emptyForwards:
        			// Do nothing, you are already there
        			stopLaucherMotor(); // Just a safety stop
            	break;
            	case emptyBackwards:
            		// The if statement is just for safety
            		if(laucherBackLimit.get()) { 
            			driveLaucherMotorBackwards(); 
                		current = laucherState.emptyMiddle;
            		}
            	break;
            	case emptyMiddle:
            		// The if statement is just for safety
            		if(laucherBackLimit.get()) {
            			driveLaucherMotorBackwards(); 
            			current = laucherState.emptyMiddle;
            		}
            	break;
            	case primedMiddle:
            		toggleRelease(); //Grabs the spring
            		// The if statement is just for safety
            		if(laucherBackLimit.get()) {
            			driveLaucherMotorBackwards(); 
            			current = laucherState.emptyMiddle;
            		}
            	break;
            	case primed:
            		toggleRelease();
            		current = laucherState.primed;
            	break;
            	case loaded:
            		toggleRelease(); //Grabs the spring
            		// The if statement is just for safety
            		if(laucherBackLimit.get()) {
            			driveLaucherMotorBackwards(); 
            			current = laucherState.primedMiddle;
            		}
            	break;
    		}
    	break;
    	case emptyBackwards:
    		switch(destination) {
    		case emptyForwards:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.emptyMiddle;
    			}
        	break;
        	case emptyBackwards:
        		// Do nothing
        		stopLaucherMotor(); // Just for safety
        	break;
        	case emptyMiddle:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.emptyMiddle;
    			}
        	break;
        	case primedMiddle:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.emptyMiddle;
    			}
        	break;
        	case primed:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.emptyMiddle;
    			}
        	break;
        	case loaded:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.emptyMiddle;
    			}
        	break;
		}
    	break;
    	case emptyMiddle:
    		switch(destination) {
    		case emptyForwards:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    			}
        	break;
        	case emptyBackwards:
    			// The if statement is just for safety
    			if(laucherBackLimit.get()) {
    				driveLaucherMotorBackwards();
    			}
        	break;
        	case emptyMiddle:
        		// do nothing
        		stopLaucherMotor();
        	break;
        	case primedMiddle:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    			}
        	break;
        	case primed:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    			}
        	break;
        	case loaded:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    			}
        	break;
		}
    	break;
    	case primedMiddle:
    		switch(destination) {
    		case emptyForwards:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    			}
        	break;
        	case emptyBackwards:
    			// The if statement is just for safety
    			if(laucherBackLimit.get()) {
    				driveLaucherMotorBackwards();
    			}
        	break;
        	case emptyMiddle:
    			// The if statement is just for safety
    			if(laucherBackLimit.get()) {
    				driveLaucherMotorBackwards();
    			}
        	break;
        	case primedMiddle:
        		// do nothing
        		stopLaucherMotor();
        	break;
        	case primed:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    			}
        	break;
        	case loaded:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorBackwards();
    			}
        	break;
		}
    	break;
    	case primed:
    		switch(destination) {
    		case emptyForwards:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.primedMiddle;
    			}
        	break;
        	case emptyBackwards:
    			// The if statement is just for safety
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.primedMiddle;
    			}
        	break;
        	case emptyMiddle:
        		// The if statement is just for safety
        		if(laucherBackLimit.get()) {
        			driveLaucherMotorBackwards();
        			current = laucherState.primedMiddle;
        		}
        	break;
        	case primedMiddle:
        		// The if statement is just for safety
        		if(laucherBackLimit.get()) {
        			driveLaucherMotorBackwards();
        			current = laucherState.primedMiddle;
        		}
        	break;
        	case primed:
        		// do nothing
        		stopLaucherMotor();
        	break;
        	case loaded:
        		// The if statement is just for safety
        		if(laucherBackLimit.get()) {
        			driveLaucherMotorBackwards();
        			current = laucherState.primedMiddle;
        		}
        	break;
		}
    	break;
    	case loaded:
    		switch(destination) {
    		case emptyForwards:
    			toggleRelease();
    			current = laucherState.emptyBackwards;
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.emptyMiddle;
    			}
        	break;
        	case emptyBackwards:
        		toggleRelease();
        		current = laucherState.emptyBackwards;
        	break;
        	case emptyMiddle:
    			toggleRelease();
    			current = laucherState.emptyBackwards;
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.emptyMiddle;
    			}
        	break;
        	case primedMiddle:
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.primedMiddle;
    			}
        	break;
        	case primed:
    			if(laucherFrontLimit.get()) {
    				driveLaucherMotorForwards();
    				current = laucherState.primedMiddle;
    			}
        	break;
        	case loaded:
        		// Do nothing
        		stopLaucherMotor();
        	break;
		}
    	break;
    	}
    }
    
    /********************************
     * 
     * Toggles the release valve
     * 
     ********************************/
    public void toggleRelease() {
    	laucherRelease.set(!laucherRelease.get());
    }
    
    /*********************************
     * 
     * Drives the pullBack motor 
     * forwards
     * 
     *********************************/
    public void driveLaucherMotorForwards() {
    	if(laucherFrontLimit.get()) pullBackMotor.set(SPEED);
    }
    
    /*********************************
     * 
     * Drives the pullBack motor 
     * backwards
     * 
     *********************************/
    public void driveLaucherMotorBackwards() {
    	if(laucherBackLimit.get()) pullBackMotor.set(-SPEED);
    }
    
    /*********************************
     * 
     * Stops the pullBack motor
     * 
     *********************************/
    public void stopLaucherMotor() {
    	pullBackMotor.set(0.0);
    }
    
    /*********************************
     * 
     * Elevates the motor up manually
     * 
     *********************************/
    public void elevateLaucherUp() {
    	elevationMotor.set(ELEVATION_SPEED);
    }
    
    /*********************************
     * 
     * Elevates the motor down
     * manually
     * 
     *********************************/
    public void elevateLaucherDown() {
    	elevationMotor.set(-ELEVATION_SPEED);
    }
    
    /*********************************
     * 
     * Stops elevation
     * 
     *********************************/
    public void stopElevationMotor() {
    	elevationMotor.set(0.0);
    }
    
    /***************************
     * 
     * returns elevation angle 
     * 
     * @return angle in degrees
     *
     ***************************/
    public double getAngle() {
    	return elevationAngle.get();
    }
    
	@Override
	public double getPIDSource(int marker) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setPIDOutput(double output, int marker) {
		// TODO Auto-generated method stub
		
	}
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}

