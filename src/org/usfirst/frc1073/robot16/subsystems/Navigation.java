
// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1073.robot16.subsystems;

import org.usfirst.frc1073.robot16.Robot;
import org.usfirst.frc1073.robot16.RobotMap;
import org.usfirst.frc1073.robot16.commands.NavManager;
import org.usfirst.frc1073.robot16.navClasses.Map;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.command.Subsystem;

public class Navigation extends Subsystem {

	Map gameMap;
	
	//Robot Dimensions
	private final double robotLengthX = 28;
	private final double robotLengthY = 32;

	//Not in Robot Builder yet -Matt
	private final AnalogGyro navGyro = RobotMap.navGyro;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	/**
	 * Makes the map object that holds game regions, the first time
	 * 
	 * @param robotStartX - 1/10 foot
	 * @param robotStartY - 1/10 foot
	 */
	public void initializeMap(double robotStartX, double robotStartY) {
		//Calls the map constructor, generates robot and defenses
		gameMap = new Map();

		//Calibrates the gyro
		RobotMap.navGyro.calibrate(); //IMPORTANT: ROBOT NEEDS TO STAY STATIONARY AFTER BOOT
	}

	/**
	 * Changes the map to reflect the robot's change in position
	 * 
	 * @param xDistance
	 * @param yDistance
	 */
	public void updateMap() {
		//Prepares and sends updated values to the Map for updating
		double encoderAverage = (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
		gameMap.updateRobotPosition(encoderAverage * Math.sin(navGyro.getAngle()), encoderAverage * Math.cos(navGyro.getAngle()));

	}
	/**
	 * Responsible for moving the robot to coordinates, provided 2 things:
	 * 1. Robot must be facing towards opposing alliance
	 * 2. Robot must be in front of a crossable obstacle
	 * 3. Robot must need to cross obstacles (can't navigate to destination inside neutral zone)
	 * Requirement 3 may be eliminated alter on
	 * 
	 * @param x - the final x position (10ths's of an inch)
	 * @param y - the final y position (10th's of an inch)
	 */
	public void moveTo(double x, double y, double endAngle){
		//Sets initial motor values
		double Vx = 0.9;
		double Vy = 0.9;
		
		//Sets angles
		double theta = navGyro.getAngle();
		double targetTheta = 0.0;
		
		//Initialized to the distance from robot start to total clearance of opposing defense
		double targetDistance = 94;		
		double distanceTravelled = 0.0;
		
		//TODO Needs to be calibrated, describes the aggression of drive correction algorithm
		final double k = 1.0;
		
		/*
		 * First stage drive; clears defense immediately in front of the the robot.
		 * This does not provision for any time to interact with the defense. Ideally,
		 * we'll need a switch/case block to handle each potential defense separately.
		 * This has the potential to take over most autonomous movement functions, at
		 * least to firing position. 
		 */
		while(distanceTravelled <= targetDistance){
			//TODO Make sure units from drive train are correct
			distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
			
			//Updates gyro angle
			theta = navGyro.getAngle();
			
			//Modifies voltage output to motors based on a drift correction algorithm
			Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
			Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
			
			//Prevents motors from receiving weird values outside their threshold 
			if(Vx >= 1.0){Vx = 1.0;}
			if(Vy >= 1.0){Vy = 1.0;}
			
			//Physically moves the robot using the PID move method
			Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
			
			//Will cycle until the distance is traversed
		}
		//Momentarily stops the motors
		Robot.driveTrain.getDriveCommand().movePID(0,0);
				
		/*
		 * Sets the target distance for the robot to travel
		 * 
		 * X manipulation:
		 * 	-Reduced by half the length of the robot; the initial coordinates of the robot are at the bottom left corner; this centers the robot
		 * 	-Subtracts the start X from the target X; if the robot starts halfway across the map, that's half the map it doesn't have to travel
		 * 
		 * Y manipulation:
		 * 	-Reduced by half the height of the robot; the initial coordinates of the robot are at the bottom left corner; this centers the robot
		 * 	-Subtracts the start Y from the target Y; if the robot starts halfway across the map, that's half the map it doesn't have to travel
		 * 	-Subtracts the distance already traveled by the robot, presumably only in the Y; there's been movement since the starting position
		 */
		targetDistance = Math.sqrt(Math.pow((x - (robotLengthX / 2) - Robot.robotGlobalStartX), 2) + Math.pow((y - Robot.robotGlobalStartY - distanceTravelled - (robotLengthY / 2)), 2));
	
		//If the target point is left of the robot's start location	(or at it)
		if(x <= Robot.robotGlobalStartX){
			//Supposedly, the gyro continues to the negative region (-1/0, -2.0)
			//Rotates the robot so it drives straight at the target point, saving time
			while(navGyro.getAngle() > -1*(Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(Robot.robotGlobalStartX - x))){
				Robot.driveTrain.getDriveCommand().movePID(-.75, .75);
			}
			//Sets the new target theta towards the target position
			targetTheta = -1*(Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(Robot.robotGlobalStartX - x));
		}
		else{
			//Rotates the robot so it drives straight at the target point, saving time
			while(navGyro.getAngle() < (Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(x - Robot.robotGlobalStartX))){
				Robot.driveTrain.getDriveCommand().movePID(.75, -.75);
			}
			//Sets the new target theta towards the target position
			targetTheta = (Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(x - Robot.robotGlobalStartX));
		}
		//Momentarily stops the motors (so we don't go from 3/4 back to full front)
		Robot.driveTrain.getDriveCommand().movePID(0,0);
		
		//Resets distance for 2nd stage
		distanceTravelled = 0.0;
		
		/*
		 * Begins 2nd stage. At this point, the robot is oriented towards the target point.
		 * TODO This is literally the same while loop a second time. We need to restructure
		 * this
		 */
		while(distanceTravelled <= targetDistance){
			//TODO Make sure units from drive train are correct
			distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
			
			//Updates gyro angle
			theta = navGyro.getAngle();
			
			//Modifies voltage output to motors based on a drift correction algorithm
			Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
			Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
			
			//Prevents motors from receiving weird values outside their threshold 
			if(Vx >= 1.0){Vx = 1.0;}
			if(Vy >= 1.0){Vy = 1.0;}
			
			//Physically moves the robot using the PID move method
			Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
			
			//Will cycle until the distance is traversed
		}
		//Momentarily stops the motors
		Robot.driveTrain.getDriveCommand().movePID(0,0);
		
		//Realigns the robot to the desired angle
		while(navGyro.getAngle() > endAngle){
			Robot.driveTrain.getDriveCommand().movePID(-.75, .75);
		}
		while(navGyro.getAngle() < endAngle){
					Robot.driveTrain.getDriveCommand().movePID(.75, -.75);
		}
		//Sets the new target theta towards the target position
		targetTheta = (Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(x - Robot.robotGlobalStartX));
		
		//Momentarily stops the motors (so we don't go from 3/4 back to full front
		Robot.driveTrain.getDriveCommand().movePID(0, 0);
	}
	

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new NavManager());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}
}
