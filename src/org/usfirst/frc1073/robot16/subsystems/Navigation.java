
// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1073.robot16.subsystems;

import org.usfirst.frc1073.robot16.Robot;
import org.usfirst.frc1073.robot16.RobotMap;
import org.usfirst.frc1073.robot16.commands.NavManager;
import org.usfirst.frc1073.robot16.navClasses.Map;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.command.Subsystem;

public class Navigation extends Subsystem {
	//The Map object
	private Map gameMap;
	
	//Robot Dimensions
	private final double robotLengthX = 28;
	private final double robotLengthY = 32;
	
	//Not in Robot Builder yet -Matt
	private final AnalogGyro navGyro = RobotMap.navGyro;

	//Used for relative distance tracking from encoders
	private double priorEncoderAverage = 0.0;

	//Declares motor voltage variables
	private double Vx;
	private double Vy;
			
	//Declares the initial angle measures
	private double theta;
	private double targetTheta;
			
	//Used in the isFinished() of the navDrive command
	private double targetDistance;		
	private double distanceTravelled;
			
	//TODO Needs to be calibrated, describes the aggression of drive correction algorithm
	private final double k = 1.0;
	
	

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
		setDefaultCommand(new NavManager());
	
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	/**
	 * Makes the map object that holds game regions, the first time
	 * 
	 * @param robotStartX - 1/10 foot
	 * @param robotStartY - 1/10 foot
	 */
	public void initializeMap(double robotStartX, double robotStartY) {
		//Calls the map constructor, generates robot and defenses
		gameMap = new Map();

		//Calibrates the gyro
		RobotMap.navGyro.calibrate(); //IMPORTANT: ROBOT NEEDS TO STAY STATIONARY AFTER BOOT
	}

	/**
	 * Changes the map to reflect the robot's change in position
	 * 
	 * @param xDistance
	 * @param yDistance
	 */
	public void updateMap() {
		//Prepares and sends updated values to the Map for updating
		//TODO The theta considered should take into account the initial angle, not exclusively the end
		double encoderAverage = ((Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2) - priorEncoderAverage;
		gameMap.updateRobotPosition(encoderAverage * Math.sin(navGyro.getAngle()), encoderAverage * Math.cos(navGyro.getAngle()));
		priorEncoderAverage = encoderAverage;

	}
	/**
	 * The first time navDrive configuration.
	 * Sets initial voltages, target angle,
	 * and distance to be traveled (may have
	 * to be integrated into the defenseApproach()
	 * case statements; the distance to be
	 * traveled depends completely on the 
	 * defense).
	 */
	public void driveConfig(){
		//Sets initial motor values
		this.Vx = 0.8;
		this.Vy = 0.8;
				
		//Sets angles
		this.theta = navGyro.getAngle();
		this.targetTheta = 0.0;
			
		//Initialized to the distance from robot start to total clearance of opposing defense
		this.distanceTravelled = 0.0;
	}
	/**
	 * Handles the approach to the defense. Depending on the 
	 * defense, it may relinquish control to another subsystem.
	 * Decision processing will ultimately take place through a
	 * series of switch statements. 
	 * 
	 * @param defenseID - This identifies each type of defense
	 */
	public void defenseApproach(int defenseID){
		switch(8){ //TODO Will be a variable, constant just for testing
		case 0: defense0();
			break;
		case 1: defense1();
			break;
		case 2: defense2();
			break;
		case 3: defense3();
			break;
		case 4: defense4();
			break;
		case 5: defense5();
			break;
		case 6: defense6();
			break;
		case 7: defense7();
			break;
		case 8: defense8();
			break;
		}
	}
	
	public void driveConfigStage2(){
		double x = Robot.targetXGlobal;
		double y = Robot.targetYGlobal;
		/*
		 * Sets the target distance for the robot to travel
		 * 
		 * X manipulation:
		 * 	-Reduced by half the length of the robot; the initial coordinates of the robot are at the bottom left corner; this centers the robot
		 * 	-Subtracts the start X from the target X; if the robot starts halfway across the map, that's half the map it doesn't have to travel
		 * 
		 * Y manipulation:
		 * 	-Reduced by half the height of the robot; the initial coordinates of the robot are at the bottom left corner; this centers the robot
		 * 	-Subtracts the start Y from the target Y; if the robot starts halfway across the map, that's half the map it doesn't have to travel
		 * 	-Subtracts the distance already traveled by the robot, presumably only in the Y; there's been movement since the starting position
		 */
		targetDistance = Math.sqrt(Math.pow((x - (robotLengthX / 2) - Robot.robotGlobalStartX), 2) + Math.pow((y - Robot.robotGlobalStartY - distanceTravelled - (robotLengthY / 2)), 2));
	
		//If the target point is left of the robot's start location	(or at it)
		if(x <= Robot.robotGlobalStartX){
			//Supposedly, the gyro continues to the negative region (-1/0, -2.0)
			//Rotates the robot so it drives straight at the target point, saving time
			while(navGyro.getAngle() > -1*(Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(Robot.robotGlobalStartX - x))){
				Robot.driveTrain.getDriveCommand().movePID(-.75, .75);
			}
			//Sets the new target theta towards the target position
			targetTheta = -1*(Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(Robot.robotGlobalStartX - x));
		}
		//If the target point is to the right of the robot's start location
		else{
			//Rotates the robot so it drives straight at the target point, saving time
			while(navGyro.getAngle() < (Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(x - Robot.robotGlobalStartX))){
				Robot.driveTrain.getDriveCommand().movePID(.75, -.75);
			}
			//Sets the new target theta towards the target position
			targetTheta = (Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(x - Robot.robotGlobalStartX));
		}
		
		//Momentarily stops the motors
		Robot.driveTrain.getDriveCommand().movePID(0,0);
		
		//Resets distance for 2nd stage
		distanceTravelled = 0.0;
		
	}
	
	public void postDefenseNavigation(){
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
		
		//Updates gyro angle
		theta = navGyro.getAngle();
		
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 1.0){Vx = 1.0;}
		if(Vy >= 1.0){Vy = 1.0;}
		
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
	}
	
	
	/*
	 * Methods for navigating all types of defenses,
	 * so far as drive train navigation is concerned.
	 */
	
	public void finalConfig(){
		//Momentarily stops the motors
		Robot.driveTrain.getDriveCommand().movePID(0,0);
		
		//Realigns the robot to the desired angle
		while(navGyro.getAngle() > Robot.targetAngleGlobal){
			Robot.driveTrain.getDriveCommand().movePID(-.75, .75);
		}
		while(navGyro.getAngle() < Robot.targetAngleGlobal){
					Robot.driveTrain.getDriveCommand().movePID(.75, -.75);
		}
		//Sets the new target theta towards the target position
		targetTheta = (Math.PI/2) - Math.atan((Robot.targetYGlobal - Robot.robotGlobalStartY - distanceTravelled)/(Robot.targetXGlobal - Robot.robotGlobalStartX));
	}

	/**
	 * @return True - Robot has finished navigating, False - Robot has not
	 */
	public boolean areWeThereYet(){
		if(distanceTravelled>=targetDistance){return true;}
		return false; //Else
		
	}
	
	/*
	 * Category A:
	 *    ID 0: Portcullis
	 *    ID 1: Cheval De Frise
	 * Category B:
	 *    ID 2: Moat
	 *    ID 3: Ramparts
	 * Category C:
	 *    ID 4: Drawbridge
	 *    ID 5: Sally Port
	 * Category D:
	 *    ID 6: Rock Wall
	 *    ID 7: Rough Terrain
	 * Non-Selectable:
	 *    ID 8: Low Bar
	 */
	
	//Portcullis
	private void defense0(){
		/*
		 * 1. Drive to defense
		 * 2. navigatePortcullis()
		 */
	}
	
	//Cheval De Frise
	private void defense1(){
		/*
		 * 1. Drive to defense
		 * 2. navigateCheval()
		 */
	}
	
	//Moat
	private void defense2(){
		/*
		 * 1. Drive to defense
		 * 2. navigateMoat()
		 */
	}
	
	//Ramparts
	private void defense3(){
		/*
		 * 1. Drive to defense
		 * 2. navigateRamparts()
		 */
	}
	
	//Drawbridge
	private void defense4(){
		/*
		 * 1. Drive to defense
		 * 2. navigatePort()
		 */
	}
	
	//Sally Port
	private void defense5(){
		/*
		 * 1. Drive to defense
		 * 2. navigatePort()
		 */
	}
	
	//Rock Wall
	private void defense6(){
		/*
		 * 1. Drive to defense
		 * 2. navigateWall()
		 */
	}
	
	//Rough Terrain
	private void defense7(){
		/*
		 * 1. Drive to defense
		 * 2. navigateTerrain()
		 */
	}
	
	//Low Bar
	private void defense8(){
		//The distance required for simply driving through a defense
		this.targetDistance = 94;
		
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
				
		//Updates gyro angle
		theta = navGyro.getAngle();
				
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
				
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 1.0){Vx = 1.0;}
		if(Vy >= 1.0){Vy = 1.0;}
				
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
	}
}
