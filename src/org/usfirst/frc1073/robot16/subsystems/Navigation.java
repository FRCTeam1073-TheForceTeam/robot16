
// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1073.robot16.subsystems;

import org.usfirst.frc1073.robot16.Robot;
import org.usfirst.frc1073.robot16.RobotMap;
import org.usfirst.frc1073.robot16.commands.NavManager;
import org.usfirst.frc1073.robot16.navClasses.Map;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.command.Subsystem;

public class Navigation extends Subsystem {
	//The Map object
	private Map gameMap;
	
	//Robot Dimensions
	private final double robotLengthX = 28;
	private final double robotLengthY = 32;
	
	//Necessary Auto Dimensions
	private final double autoLineOverhang = 2;
	//TODO There's space between the robot and the outerworks at the start of the match; needs updating
	private final double robotToOuterWorks = robotLengthY - autoLineOverhang;
	
	//Not in Robot Builder yet -Matt
	private final AnalogGyro navGyro = RobotMap.navGyro;

	//Used for relative distance tracking from encoders
	private double priorEncoderAverage = 0.0;

	//Declares motor voltage variables
	private double Vx;
	private double Vy;
			
	//Declares the initial angle measures
	private double theta;
	private double targetTheta;
			
	//Used in the isFinished() of the navDrive command
	private double targetDistance;		
	private double distanceTravelled;
			
	//TODO Needs to be calibrated, describes the aggression of drive correction algorithm
	private final double k = 1.0;
	
	

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
		setDefaultCommand(new NavManager());
	
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	/**
	 * Makes the map object that holds game regions, the first time
	 * 
	 * @param robotStartX - 1/10 foot
	 * @param robotStartY - 1/10 foot
	 */
	public void initializeMap(double robotStartX, double robotStartY) {
		//Calls the map constructor, generates robot and defenses
		gameMap = new Map();

		//Calibrates the gyro
		RobotMap.navGyro.calibrate(); //IMPORTANT: ROBOT NEEDS TO STAY STATIONARY AFTER BOOT
	}

	/**
	 * Changes the map to reflect the robot's change in position
	 * 
	 * @param xDistance
	 * @param yDistance
	 */
	public void updateMap() {
		//Prepares and sends updated values to the Map for updating
		//TODO The theta considered should take into account the initial angle, not exclusively the end
		double encoderAverage = ((Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2) - priorEncoderAverage;
		gameMap.updateRobotPosition(encoderAverage * Math.sin(navGyro.getAngle()), encoderAverage * Math.cos(navGyro.getAngle()));
		priorEncoderAverage = encoderAverage;

	}
	/**
	 * The first time navDrive configuration.
	 * Sets initial voltages, target angle,
	 * and distance to be traveled (may have
	 * to be integrated into the defenseApproach()
	 * case statements; the distance to be
	 * traveled depends completely on the 
	 * defense).
	 */
	public void driveConfig(){
		//Sets initial motor values
		this.Vx = 0.8;
		this.Vy = 0.8;
				
		//Sets angles
		this.theta = navGyro.getAngle();
		this.targetTheta = 0.0;
			
		//Initialized to the distance from robot start to total clearance of opposing defense
		this.distanceTravelled = 0.0;
	}
	/**
	 * Handles the approach to the defense. Depending on the 
	 * defense, it may relinquish control to another subsystem.
	 * Decision processing will ultimately take place through a
	 * series of switch statements. 
	 * 
	 * @param defenseID - This identifies each type of defense
	 */
	public void defenseApproach(int defenseID){
		switch(defenseID){
		case 0: defense0();
			break;
		case 1: defense1();
			break;
		case 2: defense2();
			break;
		case 3: defense3();
			break;
		case 4: defense4();
			break;
		case 5: defense5();
			break;
		case 6: defense6();
			break;
		case 7: defense7();
			break;
		case 8: defense8();
			break;
		}
	}
	
	public void driveConfigStage2(){
		double x = Robot.targetXGlobal;
		double y = Robot.targetYGlobal;
		/*
		 * Sets the target distance for the robot to travel
		 * 
		 * X manipulation:
		 * 	-Reduced by half the length of the robot; the initial coordinates of the robot are at the bottom left corner; this centers the robot
		 * 	-Subtracts the start X from the target X; if the robot starts halfway across the map, that's half the map it doesn't have to travel
		 * 
		 * Y manipulation:
		 * 	-Reduced by half the height of the robot; the initial coordinates of the robot are at the bottom left corner; this centers the robot
		 * 	-Subtracts the start Y from the target Y; if the robot starts halfway across the map, that's half the map it doesn't have to travel
		 * 	-Subtracts the distance already traveled by the robot, presumably only in the Y; there's been movement since the starting position
		 */
		targetDistance = Math.sqrt(Math.pow((x - (robotLengthX / 2) - Robot.robotGlobalStartX), 2) + Math.pow((y - Robot.robotGlobalStartY - distanceTravelled - (robotLengthY / 2)), 2));
	
		//If the target point is left of the robot's start location	(or at it)
		if(x <= Robot.robotGlobalStartX){
			//Supposedly, the gyro continues to the negative region (-1/0, -2.0)
			//Rotates the robot so it drives straight at the target point, saving time
			while(navGyro.getAngle() > -1*(Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(Robot.robotGlobalStartX - x))){
				Robot.driveTrain.getDriveCommand().movePID(-.75, .75);
			}
			//Sets the new target theta towards the target position
			targetTheta = -1*(Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(Robot.robotGlobalStartX - x));
		}
		//If the target point is to the right of the robot's start location
		else{
			//Rotates the robot so it drives straight at the target point, saving time
			while(navGyro.getAngle() < (Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(x - Robot.robotGlobalStartX))){
				Robot.driveTrain.getDriveCommand().movePID(.75, -.75);
			}
			//Sets the new target theta towards the target position
			targetTheta = (Math.PI/2) - Math.atan((y - Robot.robotGlobalStartY - distanceTravelled)/(x - Robot.robotGlobalStartX));
		}
		
		//Momentarily stops the motors
		Robot.driveTrain.getDriveCommand().movePID(0,0);
		
		//Resets distance for 2nd stage
		distanceTravelled = 0.0;
		
	}
	
	public void postDefenseNavigation(){
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
		
		//Updates gyro angle
		theta = navGyro.getAngle();
		
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 1.0){Vx = 1.0;}
		if(Vy >= 1.0){Vy = 1.0;}
		
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
	}
	
	
	/*
	 * Methods for navigating all types of defenses,
	 * so far as drive train navigation is concerned.
	 */
	
	public void finalConfig(){
		//Momentarily stops the motors
		Robot.driveTrain.getDriveCommand().movePID(0,0);
		
		//Realigns the robot to the desired angle
		while(navGyro.getAngle() > Robot.targetAngleGlobal){
			Robot.driveTrain.getDriveCommand().movePID(-.75, .75);
		}
		while(navGyro.getAngle() < Robot.targetAngleGlobal){
					Robot.driveTrain.getDriveCommand().movePID(.75, -.75);
		}
		//Sets the new target theta towards the target position
		targetTheta = (Math.PI/2) - Math.atan((Robot.targetYGlobal - Robot.robotGlobalStartY - distanceTravelled)/(Robot.targetXGlobal - Robot.robotGlobalStartX));
	}

	/**
	 * @return True - Robot has finished navigating, False - Robot has not
	 */
	public boolean areWeThereYet(){
		if(distanceTravelled>=targetDistance){return true;}
		return false; //Else
		
	}
	
	/*
	 * Category A:
	 *    ID 0: Portcullis
	 *    ID 1: Cheval De Frise
	 * Category B:
	 *    ID 2: Moat
	 *    ID 3: Ramparts
	 * Category C:
	 *    ID 4: Drawbridge
	 *    ID 5: Sally Port
	 * Category D:
	 *    ID 6: Rock Wall
	 *    ID 7: Rough Terrain
	 * Non-Selectable:
	 *    ID 8: Low Bar
	 */
	
	//Portcullis
	private void defense0(){
		// ~ Michaela ~ //
		
		/*
		 * Portcullis Steps
		 *    Stage One
		 * 1. Move to front of defense
		 *    Stage Two
		 * 2. Move manipulator down
		 * 3. Extend manipulator
		 * 4. Move manipulator way up
		 *    Stage Three
		 * 5. Drive hella fastfastfast
		 * 6. Retract manipulator
		 * 7. Move manipulator down
		 */
		
		//TODO initialize and create earlier but too lazy to
		boolean stageOneComplete = false;
		boolean stageTwoComplete = false;
		boolean stageThreeComplete = false;
		
		if (!stageOneComplete)
		{
			//TODO Needs distance to front of defense
			this.targetDistance = 40;
			
			
			/*
			 * In theory, this method will be called at the beginning of a match. So won't
			 * distanceTravelled initially equal 0? Or will defenseApproach() change it? If
			 * it does, I can add another variable, initialDistance and in the if statement
			 * below, subtract initialDistance from distanceTravelled in the check.
			 */
			//TODO Make sure units from drive train are correct
			distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
		
				if (this.targetDistance == distanceTravelled)
					stageOneComplete = true;
			
			//Updates gyro angle
			theta = navGyro.getAngle();
						
			//Modifies voltage output to motors based on a drift correction algorithm
			Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
			Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
						
			//Prevents motors from receiving weird values outside their threshold 
			if(Vx >= 1.0){Vx = 1.0;}
			if(Vy >= 1.0){Vy = 1.0;}
						
			//Physically moves the robot using the PID move method
			Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
		}
		
		else{
			//Move 
			
			//TODO change distance to get from inside of defense to other side
			this.targetDistance = 60;
			
			//TODO Make sure units from drive train are correct
			distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
			
			//Updates gyro
			theta = navGyro.getAngle();
			
		}
		
	}
	
	//Cheval De Frise
	private void defense1(){
		/*
		 * 1. Drive to defense
		 * 2. navigateCheval()
		 */
	}
	
	//Moat
	private void defense2(){
		//distance for driving through a defense
		this.targetDistance = 127; //TODO needs calibration
		
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
		
		//Updates gyro angle
		theta = navGyro.getAngle();
		
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 0.25){Vx = 0.25;} //TODO needs calibration
		if(Vy >= 0.25){Vy = 0.25;} //TODO needs calibration
		
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
	}
	
	//Ramparts
	private void defense3(){
		//distance for driving through a defense
		this.targetDistance = 103; //TODO needs calibration
		
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
		
		//Updates gyro angle
		theta = navGyro.getAngle();
		
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 0.7){Vx = 0.7;}
		if(Vy >= 0.7){Vy = 0.7;}
		
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
	}
	
	//Drawbridge
	private void defense4(){
		/*
		 * 1. Drive to defense
		 * 2. navigatePort()
		 */
	}
	
	//Sally Port
	private void defense5(){
		/*
		 * 1. Drive to defense
		 * 2. navigatePort()
		 */
	}
	
	//Rock Wall
	private void defense6(){
		//The distance required for simply driving through a defense
		this.targetDistance = 109; //TODO needs calibration
		
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
				
		//Updates gyro angle
		theta = navGyro.getAngle();
				
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
				
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 0.25){Vx = 0.25;}
		if(Vy >= 0.25){Vy = 0.25;}
				
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
		
	}
	
	//Rough Terrain
	//1 Stage; same as d8, but compensates by adding distance
	private void defense7(){
		//TODO Needs calibration
		this.targetDistance = 104;
		
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
		
		//Updates gyro angle
		theta = navGyro.getAngle();
				
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
				
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 1.0){Vx = 1.0;}
		if(Vy >= 1.0){Vy = 1.0;}
				
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
	}
	
	//Low Bar
	//1 Stage; this method just drives the robot under the bar
	private void defense8(){
		//The distance required for simply driving through a defense
		this.targetDistance = 94;
		
		//TODO Make sure units from drive train are correct
		distanceTravelled = distanceTravelled + (Robot.driveTrain.leftEncoderDistance() + Robot.driveTrain.rightEncoderDistance()) / 2;
				
		//Updates gyro angle
		theta = navGyro.getAngle();
				
		//Modifies voltage output to motors based on a drift correction algorithm
		Vx = Vx * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
		Vy = Vy * Math.cos(theta - targetTheta) + k * (Vx + Vy)/2 * Math.sin(theta - targetTheta);
				
		//Prevents motors from receiving weird values outside their threshold 
		if(Vx >= 1.0){Vx = 1.0;}
		if(Vy >= 1.0){Vy = 1.0;}
				
		//Physically moves the robot using the PID move method
		Robot.driveTrain.getDriveCommand().movePID(Vx,Vy);
	}
}
